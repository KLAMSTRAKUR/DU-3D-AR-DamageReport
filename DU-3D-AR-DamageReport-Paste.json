{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"-- 3D Damage Report\n-- Written by Koruzarius\n-- Some code reused from Dorian's Damage Report and Elias Villde's 3D renderer\n\n-- ... Phase 1: y=(-cos(x)+1)/1.5 \n-- Phase 2: y=(-cos(x)/4+1.75)/1.5\n\ndebug = true         --export: Debugging flag\n\nsystem.print(\"************** Launching Kor's AR Damage Report ***************\")\n\nfunction log(logOutput)\n    if (debug) then\n        system.print(logOutput)\n    end\nend\n\nfor slot_name, slot in pairs(unit) do\n\tif\n\t\ttype(slot) == \"table\"\n\t\tand type(slot.export) == \"table\"\n\t\tand slot.getClass\n\tthen\n\t\tlocal elementClass = slot.getClass():lower()\n            if elementClass:find(\"coreunit\") then\n\t\t\tcore = slot\n--            elseif elementClass:find(\"receiverunit\") then\n--\t\t\treceiver = slot\n--            elseif elementClass:find(\"itemcontainer\") then\n--\t\t\tcontainer = slot\n            elseif elementClass:find(\"databank\") then\n\t\t\tdb = slot\n--            elseif elementClass:find(\"screenunit\") then\n--\t\t\tscreen = slot\n--            elseif elementClass:find(\"emitter\") then\n--\t\t\temitter = slot\n--            elseif elementClass:find(\"force\") then\n--\t\t\tRamp = slot\n--            elseif elementClass:find(\"gear\") then\n--\t\t\tgear = slot\n--            elseif elementClass:find(\"switch\") then\n--\t\t\tButton = slot\n           end\n\n\t end\nend\n\nfunction setDbIntValue(key, value)\n    if (db~=nil) then\n        db.setIntValue(key,value)\n    end\nend\nfunction getDbIntValue(key)\n    if (db~=nil) then\n        return db.getIntValue(key)\n    end\nend\nfunction setDbFloatValue(key, value)\n    if (db~=nil) then\n        db.setFloatValue(key,value)\n    end\nend\nfunction getDbFloatValue(key)\n    if (db~=nil) then\n        return db.getFloatValue(key)\n    end\nend\nfunction setDbStringValue(key, value)\n    if (db~=nil) then\n        db.setStringValue(key,value)\n    end\nend\nfunction getDbStringValue(key)\n    if (db~=nil) then\n        return db.getStringValue(key)\n    end\nend\nfunction dbHasKey(key)\n    if (db~=nil) then\n        return db.hasKey(key)\n    else\n        return 0\n    end\nend\n\nmouseOverMissingHP = true -- export: Show the missing HP of an element when you mouse over it\ngreenOpacity = 0.2 --export: The opacity of the circles when they are in good health\ndamagedOpacity = 0.8 --export: The opacity of the circles when they are damaged\nscaleSmall = 0.1    --export: Small scale\n\noXSmall = 0         --export: x translation for small version in meters\noYSmall = -4     --export: y translation for small version in meters\noZSmall = 24       --export: z translation for small version in meters\n\noXSmall = oXSmall / 4.0\noYSmall = oYSmall / 4.0\noZSmall = oZSmall / 4.0\n\nhideDecoratives = false --export: Hide decorative elements by default\ndrawName = true\n\ndecorativePattern = \"canopy,light,landing,programming,switch,force,door,hatch,button,surrogate,chair,screen,relay,emitter,receiver,nightstand,operator,toilet,resurrection,sign,elevator,shower,bed,bench,cable,panel,trash,dresser,decorative,hologram,plant,bonsai,wingtip,antenna,barrier,sink,keyboard,carpet,helios,shelf,table,wardrobe,column,pipe,window,gate,counter,detection,pressure,telemeter,fireworks,scaffolding,throne,urinal,sofa,wooden\"\n\nstartDraw = false\nSimulationMode=false  --export: Simulate damage\nscanBatchSize = 50    --export: The number of elements that will be scanned in each pass ongoing.\n\nscanFrequency = 0.1  --export: The frequency at which the elements of your ship will be scanned\n\ntransitionDirection = 0\nsmall=true\n\npopInFrames=45 --export: The number of frames it takes to pop in\nhoverStartFrame=popInFrames/5\npopInSteps = {}\n\n\nif(dbHasKey(\"momhp\") == 0) then\n\tif(mouseOverMissingHP) then\n\t\tsetDbIntValue(\"momhp\",1)\n\telse\n\t\tsetDbIntValue(\"momhp\",0)\n\tend\nelse\n\tmouseOverMissingHP = (getDbIntValue(\"momhp\") == 1)\nend\n\n\nif(dbHasKey(\"gO\") == 0) then\n\tsetDbFloatValue(\"gO\",greenOpacity)\nelse\n\tgreenOpacity = getDbFloatValue(\"gO\") \nend\n\nif(dbHasKey(\"dO\") == 0) then\n\tsetDbFloatValue(\"dO\",damagedOpacity)\nelse\n\tdamagedOpacity = getDbFloatValue(\"dO\") \nend\n\nif(dbHasKey(\"ss\") == 0) then\n\tsetDbFloatValue(\"ss\",scaleSmall)\nelse\n\tscaleSmall = getDbFloatValue(\"ss\") \nend\n\nif(dbHasKey(\"scx\") == 0) then\n\tsetDbFloatValue(\"scx\",oXSmall)\nelse\n\toXSmall = getDbFloatValue(\"scx\") \nend\n\nif(dbHasKey(\"scy\") == 0) then\n\tsetDbFloatValue(\"scy\",oYSmall)\nelse\n\toYSmall = getDbFloatValue(\"scy\") \nend\n\nif(dbHasKey(\"scz\") == 0) then\n\tsetDbFloatValue(\"scz\",oZSmall)\nelse\n\toZSmall = getDbFloatValue(\"scz\") \nend\n\nif(dbHasKey(\"hideDec\") == 0) then\n\tif(hideDecoratives) then\n\t\tsetDbIntValue(\"hideDec\",1)\n\telse\n\t\tsetDbIntValue(\"hideDec\",0)\n\tend\nelse\n\thideDecoratives = (getDbIntValue(\"hideDec\") == 1)\nend\n\nif(dbHasKey(\"drawName\") == 0) then\n\tif(drawName) then\n\t\tsetDbIntValue(\"drawName\",1)\n\telse\n\t\tsetDbIntValue(\"drawName\",0)\n\tend\nelse\n\tdrawName = (getDbIntValue(\"drawName\") == 1)\nend\n\n\nif(dbHasKey(\"sm\") == 0) then\n\tif(SimulationMode) then\n\t\tsetDbIntValue(\"sm\",1)\n\telse\n\t\tsetDbIntValue(\"sm\",0)\n\tend\nelse\n\tSimulationMode = (getDbIntValue(\"sm\") == 1)\nend\n\nif(dbHasKey(\"sBS\") == 0) then\n\tsetDbIntValue(\"sBS\",scanBatchSize)\nelse\n\tscanBatchSize = getDbIntValue(\"sBS\") \nend\n\nif(dbHasKey(\"sF\") == 0) then\n\tsetDbFloatValue(\"sF\",scanFrequency)\nelse\n\tscanFrequency = getDbFloatValue(\"sF\") \nend\n\nif(dbHasKey(\"smallMode\") == 0) then\n\tif(small) then\n\t\tsetDbIntValue(\"smallMode\",1)\n\telse\n\t\tsetDbIntValue(\"smallMode\",0)\n\tend\nelse\n\tsmall = (getDbIntValue(\"smallMode\") == 1)\n\tlarge = (getDbIntValue(\"smallMode\") == 0)\nend\n-- Initialize Pop in sequence:\nif(dbHasKey(\"pif\") == 0) then\n\tsetDbIntValue(\"pif\",popInFrames)\nelse\n    log(\"Retreiving\")\n\tpopInFrames = getDbIntValue(\"pif\") \nend\n\n\n-- *** Decorative tag handling:\ndecorativeTags = {}\n\nfunction saveTags()\n\n\tlocal decoTagString = \"\"\n\tlog(\"Save Deco Tags.\")\n\t-- Iterate through and build a string\n\tfor _,decoName in pairs(decorativeTags) do\n\t\tdecoTagString = decoTagString .. \",\" .. decoName\n\tend\n\t-- clean leading comma\n\tdecoTagString = decoTagString:gsub(\"^,\",\"\")\n\n\tsetDbStringValue(\"decTags\",decoTagString)\nend\n\nfunction interpolateDecorativeTags()\n    log(\"Figuring out decoration tags...\")\n\n\tif(dbHasKey(\"decTags\") == 1) then\n\t\t-- If we have it in the db, pull it\n\t\tdecorativePattern = getDbStringValue(\"decTags\")\n\tend\n    local decoTags = decorativePattern:gmatch('([^,]*)') -- Gets each construct's entry in full\n    for v in decoTags do\n        table.insert(decorativeTags,v)\n    end\n\tif(dbHasKey(\"decTags\") == 0) then\n\t\tsaveTags()\n    end\nend\nfunction addDecoTag(newTag)\n    table.insert(decorativeTags,newTag)\n    recheckForDecoTagsPhase = 1\n    saveTags()\nend\n\nfunction removeDecoTag(tagToRemove)\n   local decoTagString = \"\"\n    -- Iterate through and build a string\n    for _,decoName in pairs(decorativeTags) do\n        decoTagString = decoTagString .. \",\" .. decoName\n    end\n    -- replace tag and surrounding commas with just a comma\n    decoTagString = decoTagString:gsub(\",?\" .. tagToRemove .. \",?\",\",\")\n    -- clean double commas and trim ends\n    decoTagString = decoTagString:gsub(\",,\",\",\")\n    decoTagString = decoTagString:gsub(\"^,\",\"\")\n    decoTagString = decoTagString:gsub(\",$\",\"\")\n    \n    if(db ~= nil) then\n        setDbStringValue(\"decTags\",decoTagString)\n    end\n    \n    -- Reset the table to be empty, to repopulate\n    decorativeTags = {}\n    local decoTags = decoTagString:gmatch('([^,]*)') -- Gets each construct's entry in full\n    for v in decoTags do\n        table.insert(decorativeTags,v)\n    end\n    recheckForDecoTagsPhase = 1\nend\n\ninterpolateDecorativeTags()\n\nfunction writeOutTags()\n    system.print(\"All element types containing any of these strings are considered decorative.\")\n    for _,decoName in pairs(decorativeTags) do\n        system.print(decoName)\n    end\nend\nfunction readableMiniLoc()\n    return \"(\" .. oXSmall * 4.0 .. \",\" .. oYSmall * 4.0 .. \",\" .. oZSmall * 4.0 .. \")\"\nend\n\nfunction drawHelp()\n\tsystem.print(\"/ commands. Eg. /addTag databank will add databanks to the list of elements that are decoration to be optionally hidden\")\n\tsystem.print(\"addTag - Command to add a tag to the decorations list\")\n\tsystem.print(\"removeTag - Command to remove a tag from the decorations list\")\n\tsystem.print(\"HP - Toggle HP display (auto-off in mini view)\")\n\tsystem.print(\"GoodOpacity - Opacity of undamaged elements: \" .. greenOpacity)\n\tsystem.print(\"DamagedOpacity - Opacity of damaged elements: \" .. damagedOpacity)\n\tsystem.print(\"MiniScale - Scale of mini-version - \" .. scaleSmall)\n\tsystem.print(\"MiniX - X coordinate of the mini-version: \" .. oXSmall * 4.0 )\n\tsystem.print(\"MiniY - Y coordinate of the mini-version: \" .. oYSmall * 4.0 )\n\tsystem.print(\"MiniZ - Z coordinate of the mini-version: \" .. oZSmall * 4.0 )\n\tsystem.print(\"MiniCoord - Full coordinate for the mini-version\")\n     system.print(\"Current mini-coords: \" .. readableMiniLoc())\n\tsystem.print(\"Name - Toggle Name display\")\n\tsystem.print(\"ScanBatchSize - How many elements to scan per tick: \" .. scanBatchSize)\n\tsystem.print(\"ScanFrequency - How often to scan for changes: \" .. scanFrequency)\n     system.print(\"PopInFrames - How many frames it takes to animate the pop-in: \" .. popInFrames)\n     system.print(\"Alt+1 - Toggle between mini and full views\")\n     system.print(\"Alt+2 - Toggle showing decorative elements\")\n     system.print(\"Alt+9 - Toggle demo mode (randomly shows elements as damaged and broken)\")\n     system.print(\"ListDeco - Lists the filters for decorative items\")\nend\n\nfunction initializePopIn()\n    popInSteps = {}\n    local twoPi = 2* pi\n    log(\"popInFrames: \" .. popInFrames)\n    local popInIncrement = 3*pi / popInFrames\n    popInX = popInIncrement\n    local stepIncrement = 1\n    while (popInX < 3*pi) do\n        if (popInX < pi) then\n            -- Phase 1\n             popInSteps[stepIncrement]=(-1 * cos(popInX)+1)/1.5 \n        elseif(popInX < twoPi) then\n            -- popInSteps[stepIncrement]=(-1 * cos(popInX)/4+1.75)/1.5\n            popInSteps[stepIncrement]=(-1 * cos(popInX)/3+1.6667)/1.5\n            -- Phase 2\n        else\n            --Phase 3\n            popInSteps[stepIncrement]=(-1 * cos(popInX)/12+1.41667)/1.5\n        end\n        stepIncrement = stepIncrement + 1\n        popInX = popInX + popInIncrement\n    end\nend\ninitializePopIn()\n\n\nfunction formatVec3(vecToPrint)\n    return \"(\"..vecToPrint.x..\",\"..vecToPrint.y..\",\"..vecToPrint.z..\")\"\nend\n\nrecheckForDecoTagsPhase = 0\n\nElementIds = {}\nSizes = {}\nCurrHpList = {}\nMaxHpList = {}\nCurrHpPercent = {}\nElementPositions = {}\nVisualCoordinate = {}\nColours = {}\nMissingHp = {}\nRenderLocations = {}\nPopInStep = {}\nIsDecorative = {}\nHidden = {}\nHovered = {}\nNames = {}\nElementTypeClean = {}\n\ninit=false\n\nfunction InstantiateData()\n    drawHelp()\n    log(\"Begin initialization\")\n    --    if SimulationActive == true then return end\n\n    -- Fill it, set Ack to false\n    -- when response comes in, set Ack to true\n    -- if HP differs on scan, set ack back to false\n    -- send data as long as Ack is false\n\n    NumElements = 0\n\n    elementsIdList = core.getElementIdList()\n\n    local exportData = \"\"\n\n    numItemsScanned = 0\n\n    for i, id in pairs(elementsIdList) do\n        \n        NumElements = NumElements + 1\n        Hidden[NumElements] = false\n        Hovered[NumElements] = false\n        \n        Names[NumElements] = core.getElementNameById(id):gsub(\" %[[0-9]*%]\",\"\")\n\n        local idType = core.getElementDisplayNameById(id)\n        local idTypeClean = idType:gsub(\"[%s%-]+\", \"\"):lower()\n        \n        \n        local idPos = vec3(core.getElementPositionById(id))\n        local idHP = core.getElementHitPointsById(id)\n        local idMaxHP = core.getElementMaxHitPointsById(id)\n        -- local idMass = core.getElementMassById(id)\n\n        for _,DecoTag in pairs(decorativeTags)do\n            if(idTypeClean:find(DecoTag)) then\n                IsDecorative[NumElements] = true\n                if (hideDecoratives) then\n                    Hidden[NumElements] = true\n                end\n            end\n        end\n        \n        if SimulationMode == true then\n            local dice = math.random(0, 10)\n            if dice < 2 then\n                idHP = 0\n            elseif dice >= 2 and dice < 4 then\n                idHP = math.random(1, math.ceil(idMaxHP))\n            else\n                idHP = idMaxHP\n            end\n        end\n    \n        ElementTypeClean[NumElements] = idTypeClean\n        MissingHp[NumElements] = floor(idMaxHP-idHP)\n        \n        CurrHpPercent[NumElements] = math.ceil(100 / idMaxHP * idHP)\n        \n        if(math.abs(idMaxHP - idHP) > 1 and idHP > 0) then\n            Colours[NumElements] = \"#FF\" .. string.format(\"%02x\", math.floor(127 + 1.275 * CurrHpPercent[NumElements])) .. \"00\"\n        elseif (idHP == 0) then\n            Colours[NumElements] = \"#FF0000\"\n        else\n            Colours[NumElements] = \"#00FF00\"\n        end\n        \n        ElementIds[NumElements] = id\n        \n        if idMaxHP > 0 and idMaxHP < 1000 then\n            Sizes[NumElements] = 5\n        elseif idMaxHP >= 1000 and idMaxHP < 2000 then\n            Sizes[NumElements] = 8\n        elseif idMaxHP >= 2000 and idMaxHP < 5000 then\n            Sizes[NumElements] = 12\n        elseif idMaxHP >= 5000 and idMaxHP < 10000 then\n            Sizes[NumElements] = 15\n        elseif idMaxHP >= 10000 and idMaxHP < 20000 then\n            Sizes[NumElements] = 20\n        elseif idMaxHP >= 20000 then\n            Sizes[NumElements] = 30\n        end\n        \n        MaxHpList[NumElements] = idMaxHP        \n        CurrHpList[NumElements] = idHP\n        ElementPositions[NumElements] = idPos\n        PopInStep[NumElements] = 1\n\n        numItemsScanned = numItemsScanned + 1\n        \n        \n        if(startDraw == false) then\n            unit.setTimer(\"render\",0.0001)\n            system.showScreen(1)\n            startDraw = true\n        end\n        coroutine.yield()\n    end\n\n    log(\"Done initial pass, start upkeep.\")\n    init=false\n    unit.stopTimer(\"instantiateCor\")\n    unit.setTimer(\"updateCor\", scanFrequency)\n    \n    -- Move this earlier once I can account for not having everything yet.\n    -- Back to the top unit.Start()\nend\n\nfunction UpdateDamageData()\n    --    if SimulationActive == true then return end\n\twhile(true) do\n\t\tnumItemsScanned = 0\n\n        if(recheckForDecoTagsPhase == 2) then\n            recheckForDecoTagsPhase = 0\n            log(\"Done the rescan, resuming normal operations\")\n        end\n        if(recheckForDecoTagsPhase == 1) then\n            recheckForDecoTagsPhase = 2\n            log(\"Change to deco tags found! Re-Scanning.\")\n        end\n        \n\t\tfor i=1, NumElements do\n\t\t\tlocal id = ElementIds[i]\n\n\t\t\tlocal idHP = core.getElementHitPointsById(id)\n\t\t\tlocal idMaxHP = MaxHpList[i]\n\n                if(recheckForDecoTagsPhase ~= 0) then\n                    -- DecoTags has changed, update all the tags on this cycle\n                    IsDecorative[i] = false\n                    Hidden[i] = false\n                   for _,DecoTag in pairs(decorativeTags)do\n                        if(ElementTypeClean[i]:find(DecoTag)) then\n                            IsDecorative[i] = true\n                            if (hideDecoratives) then\n                                Hidden[i] = true\n                            end\n                        end\n                    end\n\t\t\t    if(numItemsScanned > scanBatchSize/2)then\n\t\t\t        coroutine.yield()\n\t\t\t        numItemsScanned = 0\n\t\t\t    end\n                end\n            \n\t\t\tif SimulationMode == true then\n\t\t\t\tidHP = CurrHpList[i]\n\t\t\t\tlocal dice = math.random(0, 300)\n\t\t\t\tif dice < 2 then\n\t\t\t\t\tidHP = 0\n\t\t\t\telseif dice >= 2 and dice < 4 then\n\t\t\t\t\tidHP = math.random(1, math.ceil(idMaxHP))\n\t\t\t\telseif dice < 6 then\n\t\t\t\t\tidHP = idMaxHP\n\t\t\t\telse\n\t\t\t\t\tidHP = idHP\n\t\t\t\tend\n\t\t\tend\n\t\t\tCurrHpPercent[i] = math.ceil(100 / idMaxHP * idHP)\n            \n                        MissingHp[i] = floor(idMaxHP - idHP)\n            \n        if(math.abs(MissingHp[i]) > 1 and idHP > 0) then\n            Colours[i] = \"#FF\" .. string.format(\"%02x\", math.floor(127 + 1.275 * CurrHpPercent[i])) .. \"00\"\n        elseif (idHP == 0) then\n            Colours[i] = \"#FF0000\"\n        else\n            Colours[i] = \"#00FF00\"\n        end\n            \n\t\t\tCurrHpList[i] = idHP\n            \n\t\t\tnumItemsScanned = numItemsScanned + 1\n\n\t\t\tif(numItemsScanned > scanBatchSize)then\n\t\t\t\tcoroutine.yield()\n\t\t\t\tnumItemsScanned = 0\n\t\t\tend\n\t\tend\n\tend\nend\n\ninstantiateCr = coroutine.create(InstantiateData)\nupdateCr = coroutine.create(UpdateDamageData)\nunit.setTimer(\"instantiateCor\", 0.02)","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"if coroutine.status(updateCr) ~= \"dead\" and coroutine.status(updateCr) == \"suspended\" then\n    coroutine.resume(updateCr)\nelseif coroutine.status(updateCr) == \"dead\" then\n    unit.stopTimer(\"updateCor\")\nend","filter":{"args":[{"value":"updateCor"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"1"},{"code":"if coroutine.status(instantiateCr) ~= \"dead\" and coroutine.status(instantiateCr) == \"suspended\" then\n    coroutine.resume(instantiateCr)\nelseif coroutine.status(instantiateCr) == \"dead\" then\n    unit.stopTimer(\"instantiateCor\")\nend","filter":{"args":[{"value":"instantiateCor"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"-- 3D rendering data\n\n-- Define global parameters\n_width = system.getScreenWidth()\n_height = system.getScreenHeight()\n_vFov = system.getCameraVerticalFov()\n\n_near = 0.01\n_far = 1000.0\n-- To recompute on regular time\n_aspectRatio = _height/_width\n_tanFov = 1.0/math.tan(math.rad(_vFov)*0.5)\n_field = -_far/(_far-_near)\n\n--Set the computation tick\nsystem.showHelper(0)\nsystem.showScreen(1)\n\n\n\n-- unit.setTimer(\"render\",0.0001)\n-- system.showScreen(1)","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"3"},{"code":"\n-- Localisation\nlocal getCamPos, getTime = system.getCameraPos, system.getArkTime\nlocal getCamFwd, getCamRgt, getCamUp = system.getCameraForward, system.getCameraRight, system.getCameraUp\n\nlocal t0 = getTime()\n\n-- Get screen data\nlocal width = _width\nlocal height = _height\nlocal vFov = _vFov\n\nlocal tanFov, field = _tanFov, _field\nlocal af = _aspectRatio*tanFov\nlocal nq = _near*field\n\n\n-- Get camera data\nlocal pos = getCamPos()\nlocal camX, camY, camZ = pos[1], pos[2], pos[3]\nlocal fwd = getCamFwd()\nlocal camFwdX, camFwdY, camFwdZ = fwd[1], fwd[2], fwd[3]\nlocal rgt = getCamRgt()\nlocal camRgtX, camRgtY, camRgtZ = rgt[1], rgt[2], rgt[3]\nlocal up = getCamUp()\nlocal camUpX, camUpY, camUpZ = up[1], up[2], up[3]\n\n-- Set mesh properties\nlocal yaw, pitch, roll = 0, 0, 0\n\n\nlocal oX, oY, oZ = oXSmall, oYSmall, oZSmall\n-- local scale = 2\n\nlocal scaleLarge = 2\nlocal scale = scaleSmall\n\nif(large) then\n    scale= scaleLarge\n    oX, oY, oZ = 0, 0, 0\nend\n\nif(transitionDirection ~= 0) then\n    transition = transition + 0.01 * transitionDirection\n    if(transition > 1) then\n        transition = 1\n        transitionDirection = 0\n        large = true\n    end\n    if(transition < 0) then\n        transition = 0\n        transitionDirection = 0\n        small = true\n    end\n    progress = -0.5*cos(transition*math.pi) + 0.5\n    -- Run through it twice more to make it a smooth but sudden transition\n    progress = -0.5*cos(progress*math.pi) + 0.5\n    progress = -0.5*cos(progress*math.pi) + 0.5\n    scale = scaleSmall + progress*(scaleLarge-scaleSmall)\n    oX, oY, oZ = (1-progress)*oXSmall, (1-progress)*oYSmall, (1-progress)*oZSmall\nend\n\n\n-- An array of the depth of every element.\nElementDepth = {}\n\n-- Precompute cos and sin\nlocal cy, sy = cos(yaw), sin(yaw)\nlocal cp, sp = cos(pitch), sin(pitch)\nlocal cr, sr = cos(roll), sin(roll)\n\nlocal cycp, sycp = cy*cp, sy*cp\nlocal cyspsr_sycr, syspsr_cycr, cpsr = cy*sp*sr - sy*cr, sy*sp*sr + cy*cr, cp*sr\nlocal cyspcr_sysr, syspcr_cysr, cpcr = cy*sp*cr + sy*sr, sy*sp*cr - cy*sr, cp*cr\n\nlocal dX, dY, dZ = oX - camX, oY - camY, oZ - camZ\n\n-- Precompute 2\n\nlocal Mxx, Myx, Mzx, Mwx =              cycp*camRgtX + sycp*camFwdX + (-sp)*camUpX,              cycp*camRgtY + sycp*camFwdY + (-sp)*camUpY,              cycp*camRgtZ + sycp*camFwdZ + (-sp)*camUpZ, dX*camRgtX + dY*camRgtY + dZ*camRgtZ\nlocal Mxy, Myy, Mzy, Mwy = cyspsr_sycr*camRgtX + syspsr_cycr*camFwdX + cpsr*camUpX, cyspsr_sycr*camRgtY + syspsr_cycr*camFwdY + cpsr*camUpY, cyspsr_sycr*camRgtZ + syspsr_cycr*camFwdZ + cpsr*camUpZ, dX*camFwdX + dY*camFwdY + dZ*camFwdZ\nlocal Mxz, Myz, Mzz, Mwz = cyspcr_sysr*camRgtX + syspcr_cysr*camFwdX + cpcr*camUpX, cyspcr_sysr*camRgtY + syspcr_cysr*camFwdY + cpcr*camUpY, cyspcr_sysr*camRgtZ + syspcr_cysr*camFwdZ + cpcr*camUpZ,    dX*camUpX + dY*camUpY + dZ*camUpZ\nlocal Mxw, Myw, Mzw, Mww = 0, 0, 0, 1\n\nlocal MVxx, MVyx, MVzx, MVwx =      af*Mxx,      af*Myx,      af*Mzx,          af*Mwx\nlocal MVxy, MVyy, MVzy, MVwy = -tanFov*Mxz, -tanFov*Myz, -tanFov*Mzz,     -tanFov*Mwz\nlocal MVxz, MVyz, MVzz, MVwz =  -field*Mxy,  -field*Mxy,  -field*Mxy, -field*Mxy + nq\nlocal MVxw, MVyw, MVzw, MVww =         Mxz,         Myz,         Mzz,             Mwz\n\n-- local MCVxx, MCVyx, MCVzx, MCVwx =     af*camRgtX,     af*camRgtY,     af*camRgtZ,   0\n-- local MCVxy, MCVyy, MCVzy, MCVwy = -tanFov*camUpX, -tanFov*camUpY, -tanFov*camUpZ,   0\n-- local MCVxz, MCVyz, MCVzz, MCVwz = -field*camFwdX, -field*camFwdY, -field*camFwdZ,  nq\n-- local MCVxw, MCVyw, MCVzw, MCVww =         camUpX,         camUpY,         camUpZ,   0\n\n\nlocal vx, vy, vz = 0, 0, 0 \n\nfor i = 1,NumElements do\n    \n    VisualCoordinate[i] = nil\n    \n    local depth = 0\n\n    --# Compute the first vertice position for back-face culling\n\n        --Local rotations YAW, PITCH, ROLL & positionning\n    local vxT, vyT, vzT = ElementPositions[i].x*scale, ElementPositions[i].y*scale, ElementPositions[i].z*scale\n        \n    vx = vxT*cycp + vyT*sycp + vzT*(-sp) + dX\n    vy = vxT*cyspsr_sycr + vyT*syspsr_cycr + vzT*cpsr + dY\n    vz = vxT*cyspcr_sysr + vyT*syspcr_cysr + vzT*cpcr + dZ\n\n--    -- Compute dot product with normal\n--    local len = (vx*vx+vy*vy+vz*vz)^(-0.5)\n--    dot = vx*len*nMX[nId] + vy*len*nMY[nId] + vz*len*nMZ[nId]\n--    sDot[nId] = dot\n--\n--    if dot >= 0 then goto skipShape end\n\n\n   --Project camera referential\n   vxT, vyT, vzT = vx, vy, vz\n\n--   vy = vxT * camFwdX + vyT * camFwdY + vzT * camFwdZ\n   vy = vxT * Mxy + vyT * Myy + vzT * Mzy + Mwy\n   \n    if vy < 0.01 then goto skipShape end\n   ivy = 1/vy\n   \n   --Project vertice from 3D -> 2D\n   --Matrix Proj.View\n--   vx = (vxT * MCVxx + vyT * MCVyx + vzT * MCVzx + MCVwx)*ivy \n--   vy = (vxT * MCVxy + vyT * MCVyy + vzT * MCVzy + MCVwy)*ivy \n--   vz = (vxT * MCVxz + vyT * MCVyz + vzT * MCVzz + MCVwz)*ivy \n   \n     vx = (vxT * MVxx + vyT * MVyx + vzT * MVzx + MVwx)*ivy \n     vy = (vxT * MVxy + vyT * MVyy + vzT * MVzy + MVwy)*ivy \n     vz = (vxT * MVxz + vyT * MVyz + vzT * MVzz + MVwz)*ivy \n\n\n   VisualCoordinate[i] = vec3(vx,vy,vz)\n\n        depth = depth + vz\n\n    ::skipShape::\n\n-- End of the for loop, uncomment this\nend\n\n-- local sort = table.sort\n-- Well fuck. I'll deal with this later I guess =(\n-- sort(ElementDepth)\n_compTime = getTime() - t0\n\n-- ]] .. width .. [[\" height=\"]] .. height .. [[\n--  <circle cx=\"]] .. xTest .. [[\" cy=\"]] .. yTest .. [[\" r=\"80\" fill=\"green\"/>\nlocal screenContent = [[<svg viewbox=\"0 0 ]] .. _width .. [[ ]] .. _height .. [[\" class=\"MainUI\">            <style> \n            .MainUI {\n            fill: none;\n            filter: drop-shadow(0 0 1.5rem #ADD8E6);\n            stroke: #ADD8E6;\n            stroke-width: 1; \n            vertical-align:middle;\n            text-anchor:start;\n            fill: white;\n            font-family: Helvetica;\n            font-size: 20px;\n            }\n            </style>]]\n\n-- Add all the circles:\n\nlocal poppedIn = false\nfor i = 1,NumElements do\n\n    if(not hideDecoratives and Hidden[i] and not poppedIn) then\n        Hidden[i] = false\n        poppedIn = true\n        PopInStep[i] = 1\n    end\n\n    if(not Hidden[i]) then\n        hovered = false\n        if (VisualCoordinate[i] ~= nil) then\n            local opacity = damagedOpacity\n            local renderSize = Sizes[i]\n            local CurrPopInStep = PopInStep[i]\n            \n            local distanceFromFocus = math.sqrt((VisualCoordinate[i].x*VisualCoordinate[i].x)+(VisualCoordinate[i].y*VisualCoordinate[i].y))\n            \n            if(distanceFromFocus < 0.05) then\n                if(not Hovered[i]) then\n                    Hovered[i]=true\n                    PopInStep[i] = hoverStartFrame -- Testing\n                end\n                hovered = true\n            else\n                Hovered[i]=false\n            end\n            \n            if(CurrPopInStep > 0) then\n                renderSize = renderSize * popInSteps[CurrPopInStep]\n                PopInStep[i] = CurrPopInStep + 1\n                if(PopInStep[i] >= popInFrames) then\n                    PopInStep[i] = 0\n                end\n            end\n            if(CurrHpPercent[i] > 99) then\n                opacity = greenOpacity\n            end\n\n            RenderLocations[i] = vec3(VisualCoordinate[i].x*width*0.5 + width*0.5, VisualCoordinate[i].y*height*0.5 + height*0.5, 0)--VisualCoordinate[i].z)\n            \n            screenContent = screenContent .. [[<circle cx=\"]] .. RenderLocations[i].x .. [[\" cy=\"]] .. RenderLocations[i].y .. [[\" r=\"]] .. renderSize .. [[\" fill=\"]] .. Colours[i] .. [[\" opacity=\"]] .. opacity .. [[\"/>]]\n            if(hovered and MissingHp[i]>1.0) then\n                if(large and mouseOverMissingHP) then\n                    screenContent = screenContent .. [[<text x=\"]] .. RenderLocations[i].x + (renderSize/2) .. [[\" y=\"]] .. RenderLocations[i].y - (renderSize) .. [[\" font-size=\"]] .. Sizes[i]/3+10 .. [[\">]] .. MissingHp[i] .. [[</text>]]\n                end\n                if (drawName) then\n                    screenContent = screenContent .. [[<text x=\"]] .. RenderLocations[i].x + (renderSize) .. [[\" y=\"]] .. RenderLocations[i].y - (renderSize/2-6) .. [[\" font-size=\"]] .. Sizes[i]/3+6 .. [[\">]] .. Names[i] .. [[</text>]]\n                end\n            end\n        end\n    end\nend\n\n--screenContent = screenContent .. [[</svg><style>svg{ width:1920px; height:1061px; position:absolute; top:0px; left:0px;}.NotWarp{filter: drop-shadow(0 0 0.5rem #FFA500); stroke: #FFA500; stroke-width: 1; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: 10px;}.me{filter: drop-shadow(0 0 0.5rem crimson); stroke: crimson; stroke-width: 1; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: 20px;}.Warp{filter: drop-shadow(0 0 0.5rem #ADD8E6); stroke: #ADD8E6; stroke-width: 1; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: 20px;}</style>]]\nscreenContent = screenContent .. [[</svg><style>svg{ width:]] .. _width .. [[px; height:]] .. _height .. [[px; position:absolute; top:0px; left:0px;}</style>]]\nsystem.setScreen(screenContent)\n\n\n","filter":{"args":[{"value":"render"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"4"},{"code":"if(small==true) then\n    transitionDirection = 1\n    small=false\n    transition=0.13\n    if (db~=nil) then\n        setDbIntValue(\"smallMode\",0)\n    end\nend\nif(large==true) then\n    transitionDirection = -1\n    large = false\n    transition=0.85\n    if (db~=nil) then\n        setDbIntValue(\"smallMode\",1)\n    end\nend","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-4"},"key":"5"},{"code":"if(hideDecoratives) then\n    hideDecoratives = false\n    if (db~=nil) then\n        setDbIntValue(\"hideDec\",0)\n    end\nelse\n    hideDecoratives = true\n    if (db~=nil) then\n        setDbIntValue(\"hideDec\",1)\n    end\n    for i = 1,NumElements do\n        if(IsDecorative[i]) then\n            Hidden[i] = true\n        end\n    end\nend","filter":{"args":[{"value":"option2"}],"signature":"actionStart(action)","slotKey":"-4"},"key":"6"},{"code":"SimulationMode=not SimulationMode\nif (db~=nil) then\n    if(SimulationMode) then\n        setDbIntValue(\"sm\",1)\n    else\n        log(\"No longer Sim mode\")\n        setDbIntValue(\"sm\",0)\n    end\nend","filter":{"args":[{"value":"option9"}],"signature":"actionStart(action)","slotKey":"-4"},"key":"7"},{"code":"","filter":{"args":[{"value":"option3"}],"signature":"actionStart(action)","slotKey":"-4"},"key":"8"},{"code":"local callFunction, details = text:match(\"^/([^ ]*) (.*)\")\n\nsystem.print(text)\n\nif(callFunction == nil) then\n    callFunction = text:match(\"^/([^ ]*)\")\nend\n\nif(callFunction == \"addTag\") then\n    addDecoTag(details:lower())\nelseif(callFunction == \"removeTag\") then\n    removeDecoTag(details:lower())\nelseif(callFunction == \"HP\") then\n\tif(mouseOverMissingHP) then\n\t\tmouseOverMissingHP = false\n\t\tsetDbIntValue(\"momhp\",0)\n\telse\n\t\tmouseOverMissingHP = true\n\t\tsetDbIntValue(\"momhp\",1)\n\tend\nelseif(callFunction == \"GoodOpacity\") then\n\tgreenOpacity = tonumber(details)\n\tsetDbFloatValue(\"gO\",greenOpacity)\nelseif(callFunction == \"DamagedOpacity\") then\n\tdamagedOpacity = tonumber(details)\n\tsetDbFloatValue(\"dO\",damagedOpacity)\nelseif(callFunction == \"MiniScale\") then\n\tscaleSmall = tonumber(details)\n\tsetDbFloatValue(\"ss\",scaleSmall)\nelseif(callFunction == \"MiniX\") then\n\toXSmall = tonumber(details)\n    oXSmall = oXSmall / 4.0\n\tsetDbFloatValue(\"scx\",oXSmall)\nelseif(callFunction == \"MiniY\") then\n\toYSmall = tonumber(details)\n    oYSmall = oYSmall / 4.0\n\tsetDbFloatValue(\"scy\",oYSmall)\nelseif(callFunction == \"MiniZ\") then\n\toZSmall = tonumber(details)\n    oZSmall = oZSmall / 4.0\n\tsetDbFloatValue(\"scz\",oZSmall)\nelseif(callFunction == \"MiniCoord\") then\n\toXSmall, oYSmall, oZSmall = details:match(\"([^,]*),([^,]*),([^,]*)\")\n     oXSmall = tonumber(oXSmall) / 4.0\n     oYSmall = tonumber(oYSmall) / 4.0\n     oZSmall = tonumber(oZSmall) / 4.0\n    log(\"Received: \" .. readableMiniLoc())\n\tsetDbFloatValue(\"scx\",oXSmall)\n\tsetDbFloatValue(\"scy\",oYSmall)\n\tsetDbFloatValue(\"scz\",oZSmall)\nelseif(callFunction == \"Name\") then\n\tif(drawName) then\n\t\tdrawName = false\n\t\tsetDbIntValue(\"drawName\",0)\n\telse\n\t\tdrawName = true\n\t\tsetDbIntValue(\"drawName\",1)\n\tend\nelseif(callFunction == \"ScanBatchSize\") then\n\tscanBatchSize = tonumber(details)\n\tsetDbFloatValue(\"sBS\",scanBatchSize)\nelseif(callFunction == \"ScanFrequency\") then\n\tscanFrequency = tonumber(details)\n     unit.stopTimer(\"updateCor\")\n     unit.setTimer(\"updateCor\", scanFrequency)\n\tsetDbFloatValue(\"sF\",scanFrequency)\nelseif(callFunction == \"PopInFrames\") then\n    popInFrames = tonumber(details)\n    hoverStartFrame=popInFrames/5\n    initializePopIn()\n    setDbIntValue(\"pif\",popInFrames)\nelseif(callFunction:find(\"ListDeco\")) then\n    writeOutTags()\nelse\n\tdrawHelp()\nend\n\n\n","filter":{"args":[{"variable":"*"}],"signature":"inputText(text)","slotKey":"-4"},"key":"9"},{"code":"cos, sin, tan = math.cos, math.sin, math.tan\ndeg, rad = math.deg, math.rad\nfloor = math.floor\npi = math.pi","filter":{"args":[],"signature":"start()","slotKey":"-5"},"key":"10"}],"methods":[],"events":[]}