{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"-- 3D Damage Report\n-- Written by Koruzarius\n-- Some code reused from Dorian's Damage Report and Elias Villde's 3D renderer\n\n-- ... Phase 1: y=(-cos(x)+1)/1.5 \n-- Phase 2: y=(-cos(x)/4+1.75)/1.5\n\ndebug = true         --export: Debugging flag\n\nfunction log(logOutput)\n    if (debug) then\n        system.print(logOutput)\n    end\nend\n\n\nfor slot_name, slot in pairs(unit) do\n\tif\n\t\ttype(slot) == \"table\"\n\t\tand type(slot.export) == \"table\"\n\t\tand slot.getElementClass\n\tthen\n\t\tlocal elementClass = slot.getElementClass():lower()\n            log(\"Slot: \" .. elementClass)\n            if elementClass:find(\"coreunit\") then\n\t\t\tcore = slot\n--            elseif elementClass:find(\"receiverunit\") then\n--\t\t\treceiver = slot\n--            elseif elementClass:find(\"itemcontainer\") then\n--\t\t\tcontainer = slot\n            elseif elementClass:find(\"databank\") then\n\t\t\tdb = slot\n--            elseif elementClass:find(\"screenunit\") then\n--\t\t\tscreen = slot\n--            elseif elementClass:find(\"emitter\") then\n--\t\t\temitter = slot\n--            elseif elementClass:find(\"force\") then\n--\t\t\tRamp = slot\n--            elseif elementClass:find(\"gear\") then\n--\t\t\tgear = slot\n--            elseif elementClass:find(\"switch\") then\n--\t\t\tButton = slot\n           end\n\n\t end\nend\n\nif(db.hasKey(\"test\") == 0) then\n    log(\"Test is nil\")\nend\n\n\nmouseOverMissingHP = true -- export: Show the missing HP of an element when you mouse over it\nif(db.hasKey(\"momhp\") == 0) then\n    if(mouseOverMissingHP) then\n        db.setIntValue(\"momhp\",1)\n    else\n        db.setIntValue(\"momhp\",0)\n    end\nelse\n    mouseOverMissingHP = (db.getIntValue(\"momhp\") == 1)\nend\n\nmouseOverName = true -- export: Show the missing HP of an element when you mouse over it\nif(db.hasKey(\"mon\") == 0) then\n    if(mouseOverName) then\n        db.setIntValue(\"mon\",1)\n    else\n        db.setIntValue(\"mon\",0)\n    end\nelse\n    mouseOverName = (db.getIntValue(\"mon\") == 1)\nend\n\ngreenOpacity = 0.2 --export: The opacity of the circles when they are in good health\ndamagedOpacity = 0.8 --export: The opacity of the circles when they are damaged\n\nscaleSmall = 0.1    --export: Small scale\noXSmall = 0         --export: x translation for small version in meters\noYSmall = -12.2     --export: y translation for small version in meters\noZSmall = 8.5       --export: z translation for small version in meters\n\nhideDecoratives = false --export: Hide decorative elements by default\ndecorativePattern = \"canopy,light,landing,programming,switch,force,door,hatch,button,surrogate,chair,screen,relay,emitter,receiver,nightstand,operator,toilet,resurrection,sign,elevator,shower,bed,bench,cable,panel,trash,dresser,decorative,hologram,plant,bonsai,wingtip,antenna,barrier,sink,keyboard,carpet,helios,shelf,table,wardrobe,column,pipe,window,gate,counter,detection,pressure,telemeter,fireworks,scaffolding,throne,urinal,sofa,wooden\"\n\ndrawName = true\nstartDraw = false\nSimulationMode=true  --export: Simulate damage\nscanBatchSize = 20    --export: The number of elements that will be scanned in each pass ongoing.\nscanFrequency = 0.25  --export: The frequency at which the elements of your ship will be scanned\n\ntransitionDirection = 0\nsmall=true\n\n-- *** Decorative tag handling:\nfunction saveTags()\n   local decoTagString = \"\"\n    -- Iterate through and build a string\n    for _,testX in pairs(decorativeTags) do\n        decoTagString = decoTagString .. \",\" .. textX\n    end\n    -- clean leading comma\n    decoTagString = decoTagString:gsub(\"^,\",\"\")\n\n    db.setStringValue(\"decTags\",decoTagString)\nend\n\ndecorativeTags = {}\nfunction interpolateDecorativeTags()\n    log(\"Figuring out decoration tags...\")\n    if(db.hasKey(\"decTags\") == 1) then\n        -- If we have it in the db, pull it\n        decorativePattern = db.getStringValue(\"decTags\")\n    end\n    local decoTags = decorativePattern:gmatch('([^,]*)') -- Gets each construct's entry in full\n    for v in decoTags do\n        log(\"Test deco 1: \" .. v)\n        table.insert(decorativeTags,v)\n    end\n    if(db.hasKey(\"decTags\") == 0) then\n        saveTags()\n    end\nend\nfunction addDecoTag(newTag)\n    table.insert(decorativeTags,newTag)\n    saveTags()\nend\n\nfunction removeDecoTag(tagToRemove)\n   local decoTagString = \"\"\n    -- Iterate through and build a string\n    for _,testX in pairs(decorativeTags) do\n        decoTagString = decoTagString .. \",\" .. textX\n    end\n    -- replace tag and surrounding commas with just a comma\n    decoTagString = decoTagString:gsub(\",?\" .. tagToRemove .. \",?\",\",\")\n    -- clean double commas and trim ends\n    decoTagString = decoTagString:gsub(\",,\",\",\")\n    decoTagString = decoTagString:gsub(\"^,\",\"\")\n    decoTagString = decoTagString:gsub(\",$\",\"\")\n    \n    db.setStringValue(\"decTags\",decoTagString)\n    \n    -- Reset the table to be empty, to repopulate\n    decorativeTags = {}\n    local decoTags = decoTagString:gmatch('([^,]*)') -- Gets each construct's entry in full\n    for v in decoTags do\n        log(\"Test deco 2: \" .. v)\n        table.insert(decorativeTags,v)\n    end\n\nend\n\n\ninterpolateDecorativeTags()\n-- Initialize Pop in sequence:\npopInFrames=45 --export: The number of frames it takes to pop in\npopInSteps = {}\nfunction initializePopIn()\n    local twoPi = 2* pi\n    local popInIncrement = 3*pi / popInFrames\n    popInX = popInIncrement\n    local stepIncrement = 1\n    log(\"Initializing pop-in sequence...\")\n    while (popInX < 3*pi) do\n        if (popInX < pi) then\n            -- Phase 1\n             popInSteps[stepIncrement]=(-1 * cos(popInX)+1)/1.5 \n        elseif(popInX < twoPi) then\n            -- popInSteps[stepIncrement]=(-1 * cos(popInX)/4+1.75)/1.5\n            popInSteps[stepIncrement]=(-1 * cos(popInX)/3+1.6667)/1.5\n            -- Phase 2\n        else\n            --Phase 3\n            popInSteps[stepIncrement]=(-1 * cos(popInX)/12+1.41667)/1.5\n        end\n        \n        log(stepIncrement .. \": \" .. popInSteps[stepIncrement])\n        stepIncrement = stepIncrement + 1\n        popInX = popInX + popInIncrement\n    end\nend\ninitializePopIn()\n\n\nfunction formatVec3(vecToPrint)\n    return \"(\"..vecToPrint.x..\",\"..vecToPrint.y..\",\"..vecToPrint.z..\")\"\nend\n\n\n\nElementIds = {}\nSizes = {}\nCurrHpList = {}\nMaxHpList = {}\nCurrHpPercent = {}\nElementPositions = {}\nVisualCoordinate = {}\nColours = {}\nMissingHp = {}\nRenderLocations = {}\nPopInStep = {}\nIsDecorative = {}\nHidden = {}\nHovered = {}\nNames = {}\n\nfunction InstantiateData()\n    log(\"Begin initialization\")\n    --    if SimulationActive == true then return end\n\n    -- Fill it, set Ack to false\n    -- when response comes in, set Ack to true\n    -- if HP differs on scan, set ack back to false\n    -- send data as long as Ack is false\n\n    NumElements = 0\n\n    elementsIdList = core.getElementIdList()\n\n    local exportData = \"\"\n\n    numItemsScanned = 0\n\n    for i, id in pairs(elementsIdList) do\n        \n        NumElements = NumElements + 1\n        Hidden[NumElements] = false\n        Hovered[NumElements] = false\n        \n        Names[NumElements] = core.getElementNameById(id):gsub(\" %[[0-9]*%]\",\"\")\n\n        local idType = core.getElementTypeById(id)\n        local idTypeClean = idType:gsub(\"[%s%-]+\", \"\"):lower()\n        \n        \n        local idPos = vec3(core.getElementPositionById(id))\n        local idHP = core.getElementHitPointsById(id)\n        local idMaxHP = core.getElementMaxHitPointsById(id)\n        -- local idMass = core.getElementMassById(id)\n\n        for _,DecoTag in pairs(decorativeTags)do\n            if(idTypeClean:find(DecoTag)) then\n                IsDecorative[NumElements] = true\n                if (hideDecoratives) then\n                    Hidden[NumElements] = true\n                end\n            end\n        end\n        \n        if SimulationMode == true then\n            local dice = math.random(0, 10)\n            if dice < 2 then\n                idHP = 0\n            elseif dice >= 2 and dice < 4 then\n                idHP = math.random(1, math.ceil(idMaxHP))\n            else\n                idHP = idMaxHP\n            end\n        end\n    \n        MissingHp[NumElements] = floor(idMaxHP-idHP)\n        \n        CurrHpPercent[NumElements] = math.ceil(100 / idMaxHP * idHP)\n        \n        if(math.abs(idMaxHP - idHP) > 1 and idHP > 0) then\n            Colours[NumElements] = \"#FF\" .. string.format(\"%02x\", math.floor(127 + 1.275 * CurrHpPercent[NumElements])) .. \"00\"\n        elseif (idHP == 0) then\n            Colours[NumElements] = \"#FF0000\"\n        else\n            Colours[NumElements] = \"#00FF00\"\n        end\n        \n        ElementIds[NumElements] = id\n        \n        if idMaxHP > 0 and idMaxHP < 1000 then\n            Sizes[NumElements] = 5\n        elseif idMaxHP >= 1000 and idMaxHP < 2000 then\n            Sizes[NumElements] = 8\n        elseif idMaxHP >= 2000 and idMaxHP < 5000 then\n            Sizes[NumElements] = 12\n        elseif idMaxHP >= 5000 and idMaxHP < 10000 then\n            Sizes[NumElements] = 15\n        elseif idMaxHP >= 10000 and idMaxHP < 20000 then\n            Sizes[NumElements] = 20\n        elseif idMaxHP >= 20000 then\n            Sizes[NumElements] = 30\n        end\n        \n        MaxHpList[NumElements] = idMaxHP        \n        CurrHpList[NumElements] = idHP\n        ElementPositions[NumElements] = idPos\n        PopInStep[NumElements] = 1\n\n        numItemsScanned = numItemsScanned + 1\n        \n        \n        if(startDraw == false) then\n            unit.setTimer(\"render\",0.0001)\n            system.showScreen(1)\n            startDraw = true\n        end\n        coroutine.yield()\n    end\n\n    log(\"Done initial pass, start upkeep.\")\n    unit.stopTimer(\"instantiateCor\")\n    unit.setTimer(\"updateCor\", scanFrequency)\n    \n    -- Move this earlier once I can account for not having everything yet.\n    -- Back to the top unit.Start()\nend\n\nfunction UpdateDamageData()\n    --    if SimulationActive == true then return end\n\twhile(true) do\n\t\tnumItemsScanned = 0\n\n\t\tfor i=1, NumElements do\n\t\t\tlocal id = ElementIds[i]\n\n\t\t\tlocal idHP = core.getElementHitPointsById(id)\n\t\t\tlocal idMaxHP = MaxHpList[i]\n\n\t\t\tif SimulationMode == true then\n\t\t\t\tidHP = CurrHpList[i]\n\t\t\t\tlocal dice = math.random(0, 300)\n\t\t\t\tif dice < 2 then\n\t\t\t\t\tidHP = 0\n\t\t\t\telseif dice >= 2 and dice < 4 then\n\t\t\t\t\tidHP = math.random(1, math.ceil(idMaxHP))\n\t\t\t\telseif dice < 6 then\n\t\t\t\t\tidHP = idMaxHP\n\t\t\t\telse\n\t\t\t\t\tidHP = idHP\n\t\t\t\tend\n\t\t\tend\n\t\t\tCurrHpPercent[i] = math.ceil(100 / idMaxHP * idHP)\n            \n                        MissingHp[i] = floor(idMaxHP - idHP)\n            \n        if(math.abs(MissingHp[i]) > 1 and idHP > 0) then\n            Colours[i] = \"#FF\" .. string.format(\"%02x\", math.floor(127 + 1.275 * CurrHpPercent[i])) .. \"00\"\n        elseif (idHP == 0) then\n            Colours[i] = \"#FF0000\"\n        else\n            Colours[i] = \"#00FF00\"\n        end\n            \n\t\t\tCurrHpList[i] = idHP\n            \n\t\t\tnumItemsScanned = numItemsScanned + 1\n\n\t\t\tif(numItemsScanned > scanBatchSize)then\n\t\t\t\tcoroutine.yield()\n\t\t\t\tnumItemsScanned = 0\n\t\t\tend\n\t\tend\n\tend\nend\n\ninstantiateCr = coroutine.create(InstantiateData)\nupdateCr = coroutine.create(UpdateDamageData)\nunit.setTimer(\"instantiateCor\", 0.02)\n\n\n\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"if coroutine.status(updateCr) ~= \"dead\" and coroutine.status(updateCr) == \"suspended\" then\n    coroutine.resume(updateCr)\nelseif coroutine.status(updateCr) == \"dead\" then\n    unit.stopTimer(\"updateCor\")\nend","filter":{"args":[{"value":"updateCor"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"1"},{"code":"if coroutine.status(instantiateCr) ~= \"dead\" and coroutine.status(instantiateCr) == \"suspended\" then\n    coroutine.resume(instantiateCr)\nelseif coroutine.status(instantiateCr) == \"dead\" then\n    unit.stopTimer(\"instantiateCor\")\nend","filter":{"args":[{"value":"instantiateCor"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"-- 3D rendering data\n\n-- Define global parameters\n_width = system.getScreenWidth()\n_height = system.getScreenHeight()\n_vFov = system.getCameraVerticalFov()\n\n_near = 0.01\n_far = 1000.0\n-- To recompute on regular time\n_aspectRatio = _height/_width\n_tanFov = 1.0/math.tan(math.rad(_vFov)*0.5)\n_field = -_far/(_far-_near)\n\n--Set the computation tick\nsystem.showHelper(0)\nsystem.showScreen(1)\n\n\n_fpsTime = system.getTime()\n_compTime = system.getTime()\n_rendTime = system.getTime()\n\n\n\n-- unit.setTimer(\"render\",0.0001)\n-- system.showScreen(1)","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"3"},{"code":"\n-- Localisation\nlocal getCamPos, getTime = system.getCameraPos, system.getArkTime\nlocal getCamFwd, getCamRgt, getCamUp = system.getCameraForward, system.getCameraRight, system.getCameraUp\n\nlocal t0 = getTime()\n\n-- Get screen data\nlocal width = _width\nlocal height = _height\nlocal vFov = _vFov\n\nlocal tanFov, field = _tanFov, _field\nlocal af = _aspectRatio*tanFov\nlocal nq = _near*field\n\n\n-- Get camera data\nlocal pos = getCamPos()\nlocal camX, camY, camZ = pos[1], pos[2], pos[3]\nlocal fwd = getCamFwd()\nlocal camFwdX, camFwdY, camFwdZ = fwd[1], fwd[2], fwd[3]\nlocal rgt = getCamRgt()\nlocal camRgtX, camRgtY, camRgtZ = rgt[1], rgt[2], rgt[3]\nlocal up = getCamUp()\nlocal camUpX, camUpY, camUpZ = up[1], up[2], up[3]\n\n-- Set mesh properties\nlocal yaw, pitch, roll = 0, 0, 0\n\n\nlocal oX, oY, oZ = oXSmall, oYSmall, oZSmall\n-- local scale = 2\n\nlocal scaleLarge = 2\nlocal scale = scaleSmall\n\nif(large) then\n    scale= scaleLarge\n    oX, oY, oZ = 0, 0, 0\nend\n\nif(transitionDirection ~= 0) then\n    transition = transition + 0.01 * transitionDirection\n    if(transition > 1) then\n        transition = 1\n        transitionDirection = 0\n        large = true\n    end\n    if(transition < 0) then\n        transition = 0\n        transitionDirection = 0\n        small = true\n    end\n    progress = -0.5*cos(transition*math.pi) + 0.5\n    -- Run through it twice more to make it a smooth but sudden transition\n    progress = -0.5*cos(progress*math.pi) + 0.5\n    progress = -0.5*cos(progress*math.pi) + 0.5\n    scale = scaleSmall + progress*(scaleLarge-scaleSmall)\n    oX, oY, oZ = (1-progress)*oXSmall, (1-progress)*oYSmall, (1-progress)*oZSmall\nend\n\n\n-- An array of the depth of every element.\nElementDepth = {}\n\n-- Precompute cos and sin\nlocal cy, sy = cos(yaw), sin(yaw)\nlocal cp, sp = cos(pitch), sin(pitch)\nlocal cr, sr = cos(roll), sin(roll)\n\nlocal cycp, sycp = cy*cp, sy*cp\nlocal cyspsr_sycr, syspsr_cycr, cpsr = cy*sp*sr - sy*cr, sy*sp*sr + cy*cr, cp*sr\nlocal cyspcr_sysr, syspcr_cysr, cpcr = cy*sp*cr + sy*sr, sy*sp*cr - cy*sr, cp*cr\n\nlocal dX, dY, dZ = oX - camX, oY - camY, oZ - camZ\n\n-- Precompute 2\n\nlocal Mxx, Myx, Mzx, Mwx =              cycp*camRgtX + sycp*camFwdX + (-sp)*camUpX,              cycp*camRgtY + sycp*camFwdY + (-sp)*camUpY,              cycp*camRgtZ + sycp*camFwdZ + (-sp)*camUpZ, dX*camRgtX + dY*camRgtY + dZ*camRgtZ\nlocal Mxy, Myy, Mzy, Mwy = cyspsr_sycr*camRgtX + syspsr_cycr*camFwdX + cpsr*camUpX, cyspsr_sycr*camRgtY + syspsr_cycr*camFwdY + cpsr*camUpY, cyspsr_sycr*camRgtZ + syspsr_cycr*camFwdZ + cpsr*camUpZ, dX*camFwdX + dY*camFwdY + dZ*camFwdZ\nlocal Mxz, Myz, Mzz, Mwz = cyspcr_sysr*camRgtX + syspcr_cysr*camFwdX + cpcr*camUpX, cyspcr_sysr*camRgtY + syspcr_cysr*camFwdY + cpcr*camUpY, cyspcr_sysr*camRgtZ + syspcr_cysr*camFwdZ + cpcr*camUpZ,    dX*camUpX + dY*camUpY + dZ*camUpZ\nlocal Mxw, Myw, Mzw, Mww = 0, 0, 0, 1\n\nlocal MVxx, MVyx, MVzx, MVwx =      af*Mxx,      af*Myx,      af*Mzx,          af*Mwx\nlocal MVxy, MVyy, MVzy, MVwy = -tanFov*Mxz, -tanFov*Myz, -tanFov*Mzz,     -tanFov*Mwz\nlocal MVxz, MVyz, MVzz, MVwz =  -field*Mxy,  -field*Mxy,  -field*Mxy, -field*Mxy + nq\nlocal MVxw, MVyw, MVzw, MVww =         Mxz,         Myz,         Mzz,             Mwz\n\n-- local MCVxx, MCVyx, MCVzx, MCVwx =     af*camRgtX,     af*camRgtY,     af*camRgtZ,   0\n-- local MCVxy, MCVyy, MCVzy, MCVwy = -tanFov*camUpX, -tanFov*camUpY, -tanFov*camUpZ,   0\n-- local MCVxz, MCVyz, MCVzz, MCVwz = -field*camFwdX, -field*camFwdY, -field*camFwdZ,  nq\n-- local MCVxw, MCVyw, MCVzw, MCVww =         camUpX,         camUpY,         camUpZ,   0\n\n\nlocal vx, vy, vz = 0, 0, 0 \n\nfor i = 1,NumElements do\n    \n    VisualCoordinate[i] = nil\n    \n    local depth = 0\n\n    --# Compute the first vertice position for back-face culling\n\n        --Local rotations YAW, PITCH, ROLL & positionning\n    local vxT, vyT, vzT = ElementPositions[i].x*scale, ElementPositions[i].y*scale, ElementPositions[i].z*scale\n        \n    vx = vxT*cycp + vyT*sycp + vzT*(-sp) + dX\n    vy = vxT*cyspsr_sycr + vyT*syspsr_cycr + vzT*cpsr + dY\n    vz = vxT*cyspcr_sysr + vyT*syspcr_cysr + vzT*cpcr + dZ\n\n--    -- Compute dot product with normal\n--    local len = (vx*vx+vy*vy+vz*vz)^(-0.5)\n--    dot = vx*len*nMX[nId] + vy*len*nMY[nId] + vz*len*nMZ[nId]\n--    sDot[nId] = dot\n--\n--    if dot >= 0 then goto skipShape end\n\n\n   --Project camera referential\n   vxT, vyT, vzT = vx, vy, vz\n\n--   vy = vxT * camFwdX + vyT * camFwdY + vzT * camFwdZ\n   vy = vxT * Mxy + vyT * Myy + vzT * Mzy + Mwy\n   \n    if vy < 0.01 then goto skipShape end\n   ivy = 1/vy\n   \n   --Project vertice from 3D -> 2D\n   --Matrix Proj.View\n--   vx = (vxT * MCVxx + vyT * MCVyx + vzT * MCVzx + MCVwx)*ivy \n--   vy = (vxT * MCVxy + vyT * MCVyy + vzT * MCVzy + MCVwy)*ivy \n--   vz = (vxT * MCVxz + vyT * MCVyz + vzT * MCVzz + MCVwz)*ivy \n   \n     vx = (vxT * MVxx + vyT * MVyx + vzT * MVzx + MVwx)*ivy \n     vy = (vxT * MVxy + vyT * MVyy + vzT * MVzy + MVwy)*ivy \n     vz = (vxT * MVxz + vyT * MVyz + vzT * MVzz + MVwz)*ivy \n\n\n   VisualCoordinate[i] = vec3(vx,vy,vz)\n\n        depth = depth + vz\n\n    ::skipShape::\n\n-- End of the for loop, uncomment this\nend\n\n-- local sort = table.sort\n-- Well fuck. I'll deal with this later I guess =(\n-- sort(ElementDepth)\n_compTime = getTime() - t0\n\n-- ]] .. width .. [[\" height=\"]] .. height .. [[\n--  <circle cx=\"]] .. xTest .. [[\" cy=\"]] .. yTest .. [[\" r=\"80\" fill=\"green\"/>\nlocal screenContent = [[<svg viewbox=\"0 0 1920 1061\" class=\"Warp\">            <style> \n            .MainUI {\n            stroke-width: 3; \n            fill: none;\n            }\n            /*path{ stroke:currentColor; fill:currentColor; stroke-width:1 }*/\n            </style>]]\n\n-- Add all the circles:\n\nlocal poppedIn = false\nfor i = 1,NumElements do\n\n    if(not hideDecoratives and Hidden[i] and not poppedIn) then\n        Hidden[i] = false\n        poppedIn = true\n        PopInStep[i] = 1\n    end\n\n    if(not Hidden[i]) then\n        hovered = false\n        if (VisualCoordinate[i] ~= nil) then\n            local opacity = damagedOpacity\n            local renderSize = Sizes[i]\n            local CurrPopInStep = PopInStep[i]\n            \n            local distanceFromFocus = math.sqrt((VisualCoordinate[i].x*VisualCoordinate[i].x)+(VisualCoordinate[i].y*VisualCoordinate[i].y))\n            \n            if(distanceFromFocus < 0.05) then\n                if(not Hovered[i]) then\n                    Hovered[i]=true\n                    PopInStep[i] = 10 -- Testing\n                end\n                hovered = true\n            else\n                Hovered[i]=false\n            end\n            \n            if(CurrPopInStep > 0) then\n                renderSize = renderSize * popInSteps[CurrPopInStep]\n                PopInStep[i] = CurrPopInStep + 1\n                if(PopInStep[i] >= popInFrames) then\n                    PopInStep[i] = 0\n                end\n            end\n            if(CurrHpPercent[i] > 99) then\n                opacity = greenOpacity\n            end\n    \n\n    \n            RenderLocations[i] = vec3(VisualCoordinate[i].x*width*0.5 + width*0.5, VisualCoordinate[i].y*height*0.5 + height*0.5, 0)--VisualCoordinate[i].z)\n            \n            screenContent = screenContent .. [[<circle cx=\"]] .. RenderLocations[i].x .. [[\" cy=\"]] .. RenderLocations[i].y .. [[\" r=\"]] .. renderSize .. [[\" fill=\"]] .. Colours[i] .. [[\" opacity=\"]] .. opacity .. [[\"/>]]\n            if(hovered and MissingHp[i]>1.0) then\n                if(large) then\n                    screenContent = screenContent .. [[<text x=\"]] .. RenderLocations[i].x + (renderSize/2) .. [[\" y=\"]] .. RenderLocations[i].y - (renderSize) .. [[\" font-size=\"]] .. Sizes[i]/3+10 .. [[\">]] .. MissingHp[i] .. [[</text>]]\n                end\n                if (drawName) then\n                    screenContent = screenContent .. [[<text x=\"]] .. RenderLocations[i].x + (renderSize) .. [[\" y=\"]] .. RenderLocations[i].y - (renderSize/2-6) .. [[\" font-size=\"]] .. Sizes[i]/3+6 .. [[\">]] .. Names[i] .. [[</text>]]\n                end\n            end\n        end\n    end\nend\n\nscreenContent = screenContent .. [[</svg><style>svg{ width:1920px; height:1061px; position:absolute; top:0px; left:0px;}.NotWarp{filter: drop-shadow(0 0 0.5rem #FFA500); stroke: #FFA500; stroke-width: 1; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: 10px;}.me{filter: drop-shadow(0 0 0.5rem crimson); stroke: crimson; stroke-width: 1; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: 20px;}.Warp{filter: drop-shadow(0 0 0.5rem #ADD8E6); stroke: #ADD8E6; stroke-width: 1; vertical-align:middle; text-anchor:start; fill: white; font-family: Helvetica; font-size: 20px;}</style>]]\nsystem.setScreen(screenContent)\n\n\n","filter":{"args":[{"value":"render"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"4"},{"code":"if(small==true) then\n    transitionDirection = 1\n    small=false\n    transition=0.13\nend\nif(large==true) then\n    transitionDirection = -1\n    large = false\n    transition=0.85\nend","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"5"},{"code":"if(hideDecoratives) then\n    hideDecoratives = false\nelse\n    hideDecoratives = true\n    for i = 1,NumElements do\n        if(IsDecorative[i]) then\n            Hidden[i] = true\n        end\n    end\nend","filter":{"args":[{"value":"option2"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"6"},{"code":"SimulationMode=not SimulationMode","filter":{"args":[{"value":"option9"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"7"},{"code":"cos, sin, tan = math.cos, math.sin, math.tan\ndeg, rad = math.deg, math.rad\nfloor = math.floor\npi = math.pi","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"8"}],"methods":[],"events":[]}